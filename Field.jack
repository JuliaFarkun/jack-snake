class Field {
    field Array cells; 
    static int seed;

    /** 
     * Конструктор поля.
     * Создаём массив ячеек с шагом 16 по обеим осям (от (0, 16) до (512, 256)).
     */
<<<<<<< Updated upstream
    constructor Field new() {
=======
    constructor Field new(int newSeed) {
        var int i, j;
        let seed = newSeed;
>>>>>>> Stashed changes
        let cells = Array.new(32 * 15); // Массив на 480 ячеек
        var int i, j;
        
        // Заполняем поле ячейками
        let i = 16;
        while (i < 256) {
            let j = 0;
            while (j < 512) {
                // Создаём ячейки с координатами угла (j, i)
<<<<<<< Updated upstream
                let cells[GetHashCode(j, i)] = Cell.new(j, i);
=======
                let cells[Field.GetHashCode(j, i)] = Cell.new(j, i, Field.GetHashCode(j, i));
>>>>>>> Stashed changes
                let j = j + 16;
            }
            let i = i + 16;
        }
        return this;
    }

    /** 
     * Получаем хеш-код ячейки по её координатам.
     * Хеш-код — номер ячейки в массиве.
     */
    function int GetHashCode(int x, int y) {
        if ((x < 0) | (x > 512) | (y < 16) | (y > 256)) {
            return -1;
        }
        let y = y - 16;
        let x = x - (x - (x / 16 * 16));
        let y = y - (y - (y / 16 * 16));
        return (x / 16) + (y * 2);
    }

    /** 
     * Установка яблока в рандомную ячейку
     */
    function void createApple(int num) {
        var Cell currentCell;
        var int numberOfCell;

        //тестовая версия, где индекс передаётся
        let numberOfCell = num;

        // выбор ячейки
        
        // Пока ячейка не пуста, выбираем другую
        /*while (~(currentCell.getType() = 0)) {

            // выбор ячейки

        }*/
        // Отрисовываем яблоко на поле
        do currentCell.setType(2); 
        return;
    }

    function int getTypeOfCell(int index) {
        return cells[index].getType();
    }

    function Cell getCell(int index) {
        return cells[index];
    }


    /** 
     * Найти соседнюю ячейку с соответствующей стороны.
     * Если находимся на краю, возвращаем -1.
     */
    function int getLeft(int currentHash) {
        if (currentHash % 32 > 0) { 
            return currentHash - 1;
        } else {
            return -1; 
        }

    function int getRight(int currentHash) {
        if (currentHash % 32 < 31) { 
            return currentHash + 1;
        } else {
            return -1; 
        }
    }

    function int getUp(int currentHash) {
        if (currentHash / 32 > 0) { 
            return currentHash - 32;
        } else {
            return -1; 
        }
    }

    function int getDown(int currentHash) {
        if (currentHash / 32 < 14) { 
            return currentHash + 32;
        } else {
            return -1; 
        }
    }


    function void dispose() {
        var int i;
        let i = 0;
        while (i < 479) {
            do cells[i].dispose();
            let i = i + 1;
        }
        do cells.dispose();
        do Memory.deAlloc(this);
        return;
    }
}
